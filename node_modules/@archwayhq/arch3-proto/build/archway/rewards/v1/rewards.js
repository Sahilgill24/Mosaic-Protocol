"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlatFee = exports.RewardsRecord = exports.TxRewards = exports.BlockRewards = exports.ContractMetadata = exports.Params = void 0;
/* eslint-disable */
const coin_1 = require("../../../cosmos/base/v1beta1/coin");
const timestamp_1 = require("../../../google/protobuf/timestamp");
const binary_1 = require("../../../binary");
const math_1 = require("@cosmjs/math");
const helpers_1 = require("../../../helpers");
function createBaseParams() {
    return {
        inflationRewardsRatio: "",
        txFeeRebateRatio: "",
        maxWithdrawRecords: BigInt(0),
        minPriceOfGas: coin_1.DecCoin.fromPartial({})
    };
}
exports.Params = {
    typeUrl: "/archway.rewards.v1.Params",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.inflationRewardsRatio !== "") {
            writer.uint32(10).string(math_1.Decimal.fromUserInput(message.inflationRewardsRatio, 18).atomics);
        }
        if (message.txFeeRebateRatio !== "") {
            writer.uint32(18).string(math_1.Decimal.fromUserInput(message.txFeeRebateRatio, 18).atomics);
        }
        if (message.maxWithdrawRecords !== BigInt(0)) {
            writer.uint32(24).uint64(message.maxWithdrawRecords);
        }
        if (message.minPriceOfGas !== undefined) {
            coin_1.DecCoin.encode(message.minPriceOfGas, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.inflationRewardsRatio = math_1.Decimal.fromAtomics(reader.string(), 18).toString();
                    break;
                case 2:
                    message.txFeeRebateRatio = math_1.Decimal.fromAtomics(reader.string(), 18).toString();
                    break;
                case 3:
                    message.maxWithdrawRecords = reader.uint64();
                    break;
                case 4:
                    message.minPriceOfGas = coin_1.DecCoin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            inflationRewardsRatio: (0, helpers_1.isSet)(object.inflationRewardsRatio) ? String(object.inflationRewardsRatio) : "",
            txFeeRebateRatio: (0, helpers_1.isSet)(object.txFeeRebateRatio) ? String(object.txFeeRebateRatio) : "",
            maxWithdrawRecords: (0, helpers_1.isSet)(object.maxWithdrawRecords) ? BigInt(object.maxWithdrawRecords.toString()) : BigInt(0),
            minPriceOfGas: (0, helpers_1.isSet)(object.minPriceOfGas) ? coin_1.DecCoin.fromJSON(object.minPriceOfGas) : undefined
        };
    },
    toJSON(message) {
        const obj = {};
        message.inflationRewardsRatio !== undefined && (obj.inflationRewardsRatio = message.inflationRewardsRatio);
        message.txFeeRebateRatio !== undefined && (obj.txFeeRebateRatio = message.txFeeRebateRatio);
        message.maxWithdrawRecords !== undefined && (obj.maxWithdrawRecords = (message.maxWithdrawRecords || BigInt(0)).toString());
        message.minPriceOfGas !== undefined && (obj.minPriceOfGas = message.minPriceOfGas ? coin_1.DecCoin.toJSON(message.minPriceOfGas) : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseParams();
        message.inflationRewardsRatio = (_a = object.inflationRewardsRatio) !== null && _a !== void 0 ? _a : "";
        message.txFeeRebateRatio = (_b = object.txFeeRebateRatio) !== null && _b !== void 0 ? _b : "";
        message.maxWithdrawRecords = object.maxWithdrawRecords !== undefined && object.maxWithdrawRecords !== null ? BigInt(object.maxWithdrawRecords.toString()) : BigInt(0);
        message.minPriceOfGas = object.minPriceOfGas !== undefined && object.minPriceOfGas !== null ? coin_1.DecCoin.fromPartial(object.minPriceOfGas) : undefined;
        return message;
    },
    fromAmino(object) {
        const message = createBaseParams();
        if (object.inflation_rewards_ratio !== undefined && object.inflation_rewards_ratio !== null) {
            message.inflationRewardsRatio = object.inflation_rewards_ratio;
        }
        if (object.tx_fee_rebate_ratio !== undefined && object.tx_fee_rebate_ratio !== null) {
            message.txFeeRebateRatio = object.tx_fee_rebate_ratio;
        }
        if (object.max_withdraw_records !== undefined && object.max_withdraw_records !== null) {
            message.maxWithdrawRecords = BigInt(object.max_withdraw_records);
        }
        if (object.min_price_of_gas !== undefined && object.min_price_of_gas !== null) {
            message.minPriceOfGas = coin_1.DecCoin.fromAmino(object.min_price_of_gas);
        }
        return message;
    },
    toAmino(message) {
        const obj = {};
        obj.inflation_rewards_ratio = message.inflationRewardsRatio;
        obj.tx_fee_rebate_ratio = message.txFeeRebateRatio;
        obj.max_withdraw_records = message.maxWithdrawRecords ? message.maxWithdrawRecords.toString() : undefined;
        obj.min_price_of_gas = message.minPriceOfGas ? coin_1.DecCoin.toAmino(message.minPriceOfGas) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.Params.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.Params.decode(message.value);
    },
    toProto(message) {
        return exports.Params.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/archway.rewards.v1.Params",
            value: exports.Params.encode(message).finish()
        };
    }
};
function createBaseContractMetadata() {
    return {
        contractAddress: "",
        ownerAddress: "",
        rewardsAddress: "",
        withdrawToWallet: false
    };
}
exports.ContractMetadata = {
    typeUrl: "/archway.rewards.v1.ContractMetadata",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.contractAddress !== "") {
            writer.uint32(10).string(message.contractAddress);
        }
        if (message.ownerAddress !== "") {
            writer.uint32(18).string(message.ownerAddress);
        }
        if (message.rewardsAddress !== "") {
            writer.uint32(26).string(message.rewardsAddress);
        }
        if (message.withdrawToWallet === true) {
            writer.uint32(32).bool(message.withdrawToWallet);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseContractMetadata();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.contractAddress = reader.string();
                    break;
                case 2:
                    message.ownerAddress = reader.string();
                    break;
                case 3:
                    message.rewardsAddress = reader.string();
                    break;
                case 4:
                    message.withdrawToWallet = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            contractAddress: (0, helpers_1.isSet)(object.contractAddress) ? String(object.contractAddress) : "",
            ownerAddress: (0, helpers_1.isSet)(object.ownerAddress) ? String(object.ownerAddress) : "",
            rewardsAddress: (0, helpers_1.isSet)(object.rewardsAddress) ? String(object.rewardsAddress) : "",
            withdrawToWallet: (0, helpers_1.isSet)(object.withdrawToWallet) ? Boolean(object.withdrawToWallet) : false
        };
    },
    toJSON(message) {
        const obj = {};
        message.contractAddress !== undefined && (obj.contractAddress = message.contractAddress);
        message.ownerAddress !== undefined && (obj.ownerAddress = message.ownerAddress);
        message.rewardsAddress !== undefined && (obj.rewardsAddress = message.rewardsAddress);
        message.withdrawToWallet !== undefined && (obj.withdrawToWallet = message.withdrawToWallet);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseContractMetadata();
        message.contractAddress = (_a = object.contractAddress) !== null && _a !== void 0 ? _a : "";
        message.ownerAddress = (_b = object.ownerAddress) !== null && _b !== void 0 ? _b : "";
        message.rewardsAddress = (_c = object.rewardsAddress) !== null && _c !== void 0 ? _c : "";
        message.withdrawToWallet = (_d = object.withdrawToWallet) !== null && _d !== void 0 ? _d : false;
        return message;
    },
    fromAmino(object) {
        const message = createBaseContractMetadata();
        if (object.contract_address !== undefined && object.contract_address !== null) {
            message.contractAddress = object.contract_address;
        }
        if (object.owner_address !== undefined && object.owner_address !== null) {
            message.ownerAddress = object.owner_address;
        }
        if (object.rewards_address !== undefined && object.rewards_address !== null) {
            message.rewardsAddress = object.rewards_address;
        }
        if (object.withdraw_to_wallet !== undefined && object.withdraw_to_wallet !== null) {
            message.withdrawToWallet = object.withdraw_to_wallet;
        }
        return message;
    },
    toAmino(message) {
        const obj = {};
        obj.contract_address = message.contractAddress;
        obj.owner_address = message.ownerAddress;
        obj.rewards_address = message.rewardsAddress;
        obj.withdraw_to_wallet = message.withdrawToWallet;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.ContractMetadata.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.ContractMetadata.decode(message.value);
    },
    toProto(message) {
        return exports.ContractMetadata.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/archway.rewards.v1.ContractMetadata",
            value: exports.ContractMetadata.encode(message).finish()
        };
    }
};
function createBaseBlockRewards() {
    return {
        height: BigInt(0),
        inflationRewards: coin_1.Coin.fromPartial({}),
        maxGas: BigInt(0)
    };
}
exports.BlockRewards = {
    typeUrl: "/archway.rewards.v1.BlockRewards",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
            writer.uint32(8).int64(message.height);
        }
        if (message.inflationRewards !== undefined) {
            coin_1.Coin.encode(message.inflationRewards, writer.uint32(18).fork()).ldelim();
        }
        if (message.maxGas !== BigInt(0)) {
            writer.uint32(24).uint64(message.maxGas);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockRewards();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.height = reader.int64();
                    break;
                case 2:
                    message.inflationRewards = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.maxGas = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            height: (0, helpers_1.isSet)(object.height) ? BigInt(object.height.toString()) : BigInt(0),
            inflationRewards: (0, helpers_1.isSet)(object.inflationRewards) ? coin_1.Coin.fromJSON(object.inflationRewards) : undefined,
            maxGas: (0, helpers_1.isSet)(object.maxGas) ? BigInt(object.maxGas.toString()) : BigInt(0)
        };
    },
    toJSON(message) {
        const obj = {};
        message.height !== undefined && (obj.height = (message.height || BigInt(0)).toString());
        message.inflationRewards !== undefined && (obj.inflationRewards = message.inflationRewards ? coin_1.Coin.toJSON(message.inflationRewards) : undefined);
        message.maxGas !== undefined && (obj.maxGas = (message.maxGas || BigInt(0)).toString());
        return obj;
    },
    fromPartial(object) {
        const message = createBaseBlockRewards();
        message.height = object.height !== undefined && object.height !== null ? BigInt(object.height.toString()) : BigInt(0);
        message.inflationRewards = object.inflationRewards !== undefined && object.inflationRewards !== null ? coin_1.Coin.fromPartial(object.inflationRewards) : undefined;
        message.maxGas = object.maxGas !== undefined && object.maxGas !== null ? BigInt(object.maxGas.toString()) : BigInt(0);
        return message;
    },
    fromAmino(object) {
        const message = createBaseBlockRewards();
        if (object.height !== undefined && object.height !== null) {
            message.height = BigInt(object.height);
        }
        if (object.inflation_rewards !== undefined && object.inflation_rewards !== null) {
            message.inflationRewards = coin_1.Coin.fromAmino(object.inflation_rewards);
        }
        if (object.max_gas !== undefined && object.max_gas !== null) {
            message.maxGas = BigInt(object.max_gas);
        }
        return message;
    },
    toAmino(message) {
        const obj = {};
        obj.height = message.height ? message.height.toString() : undefined;
        obj.inflation_rewards = message.inflationRewards ? coin_1.Coin.toAmino(message.inflationRewards) : undefined;
        obj.max_gas = message.maxGas ? message.maxGas.toString() : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.BlockRewards.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.BlockRewards.decode(message.value);
    },
    toProto(message) {
        return exports.BlockRewards.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/archway.rewards.v1.BlockRewards",
            value: exports.BlockRewards.encode(message).finish()
        };
    }
};
function createBaseTxRewards() {
    return {
        txId: BigInt(0),
        height: BigInt(0),
        feeRewards: []
    };
}
exports.TxRewards = {
    typeUrl: "/archway.rewards.v1.TxRewards",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.txId !== BigInt(0)) {
            writer.uint32(8).uint64(message.txId);
        }
        if (message.height !== BigInt(0)) {
            writer.uint32(16).int64(message.height);
        }
        for (const v of message.feeRewards) {
            coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTxRewards();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.txId = reader.uint64();
                    break;
                case 2:
                    message.height = reader.int64();
                    break;
                case 3:
                    message.feeRewards.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            txId: (0, helpers_1.isSet)(object.txId) ? BigInt(object.txId.toString()) : BigInt(0),
            height: (0, helpers_1.isSet)(object.height) ? BigInt(object.height.toString()) : BigInt(0),
            feeRewards: Array.isArray(object === null || object === void 0 ? void 0 : object.feeRewards) ? object.feeRewards.map((e) => coin_1.Coin.fromJSON(e)) : []
        };
    },
    toJSON(message) {
        const obj = {};
        message.txId !== undefined && (obj.txId = (message.txId || BigInt(0)).toString());
        message.height !== undefined && (obj.height = (message.height || BigInt(0)).toString());
        if (message.feeRewards) {
            obj.feeRewards = message.feeRewards.map(e => e ? coin_1.Coin.toJSON(e) : undefined);
        }
        else {
            obj.feeRewards = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseTxRewards();
        message.txId = object.txId !== undefined && object.txId !== null ? BigInt(object.txId.toString()) : BigInt(0);
        message.height = object.height !== undefined && object.height !== null ? BigInt(object.height.toString()) : BigInt(0);
        message.feeRewards = ((_a = object.feeRewards) === null || _a === void 0 ? void 0 : _a.map(e => coin_1.Coin.fromPartial(e))) || [];
        return message;
    },
    fromAmino(object) {
        var _a;
        const message = createBaseTxRewards();
        if (object.tx_id !== undefined && object.tx_id !== null) {
            message.txId = BigInt(object.tx_id);
        }
        if (object.height !== undefined && object.height !== null) {
            message.height = BigInt(object.height);
        }
        message.feeRewards = ((_a = object.fee_rewards) === null || _a === void 0 ? void 0 : _a.map(e => coin_1.Coin.fromAmino(e))) || [];
        return message;
    },
    toAmino(message) {
        const obj = {};
        obj.tx_id = message.txId ? message.txId.toString() : undefined;
        obj.height = message.height ? message.height.toString() : undefined;
        if (message.feeRewards) {
            obj.fee_rewards = message.feeRewards.map(e => e ? coin_1.Coin.toAmino(e) : undefined);
        }
        else {
            obj.fee_rewards = [];
        }
        return obj;
    },
    fromAminoMsg(object) {
        return exports.TxRewards.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.TxRewards.decode(message.value);
    },
    toProto(message) {
        return exports.TxRewards.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/archway.rewards.v1.TxRewards",
            value: exports.TxRewards.encode(message).finish()
        };
    }
};
function createBaseRewardsRecord() {
    return {
        id: BigInt(0),
        rewardsAddress: "",
        rewards: [],
        calculatedHeight: BigInt(0),
        calculatedTime: timestamp_1.Timestamp.fromPartial({})
    };
}
exports.RewardsRecord = {
    typeUrl: "/archway.rewards.v1.RewardsRecord",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== BigInt(0)) {
            writer.uint32(8).uint64(message.id);
        }
        if (message.rewardsAddress !== "") {
            writer.uint32(18).string(message.rewardsAddress);
        }
        for (const v of message.rewards) {
            coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.calculatedHeight !== BigInt(0)) {
            writer.uint32(32).int64(message.calculatedHeight);
        }
        if (message.calculatedTime !== undefined) {
            timestamp_1.Timestamp.encode(message.calculatedTime, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRewardsRecord();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint64();
                    break;
                case 2:
                    message.rewardsAddress = reader.string();
                    break;
                case 3:
                    message.rewards.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.calculatedHeight = reader.int64();
                    break;
                case 5:
                    message.calculatedTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: (0, helpers_1.isSet)(object.id) ? BigInt(object.id.toString()) : BigInt(0),
            rewardsAddress: (0, helpers_1.isSet)(object.rewardsAddress) ? String(object.rewardsAddress) : "",
            rewards: Array.isArray(object === null || object === void 0 ? void 0 : object.rewards) ? object.rewards.map((e) => coin_1.Coin.fromJSON(e)) : [],
            calculatedHeight: (0, helpers_1.isSet)(object.calculatedHeight) ? BigInt(object.calculatedHeight.toString()) : BigInt(0),
            calculatedTime: (0, helpers_1.isSet)(object.calculatedTime) ? (0, helpers_1.fromJsonTimestamp)(object.calculatedTime) : undefined
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = (message.id || BigInt(0)).toString());
        message.rewardsAddress !== undefined && (obj.rewardsAddress = message.rewardsAddress);
        if (message.rewards) {
            obj.rewards = message.rewards.map(e => e ? coin_1.Coin.toJSON(e) : undefined);
        }
        else {
            obj.rewards = [];
        }
        message.calculatedHeight !== undefined && (obj.calculatedHeight = (message.calculatedHeight || BigInt(0)).toString());
        message.calculatedTime !== undefined && (obj.calculatedTime = (0, helpers_1.fromTimestamp)(message.calculatedTime).toISOString());
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseRewardsRecord();
        message.id = object.id !== undefined && object.id !== null ? BigInt(object.id.toString()) : BigInt(0);
        message.rewardsAddress = (_a = object.rewardsAddress) !== null && _a !== void 0 ? _a : "";
        message.rewards = ((_b = object.rewards) === null || _b === void 0 ? void 0 : _b.map(e => coin_1.Coin.fromPartial(e))) || [];
        message.calculatedHeight = object.calculatedHeight !== undefined && object.calculatedHeight !== null ? BigInt(object.calculatedHeight.toString()) : BigInt(0);
        message.calculatedTime = object.calculatedTime !== undefined && object.calculatedTime !== null ? timestamp_1.Timestamp.fromPartial(object.calculatedTime) : undefined;
        return message;
    },
    fromAmino(object) {
        var _a;
        const message = createBaseRewardsRecord();
        if (object.id !== undefined && object.id !== null) {
            message.id = BigInt(object.id);
        }
        if (object.rewards_address !== undefined && object.rewards_address !== null) {
            message.rewardsAddress = object.rewards_address;
        }
        message.rewards = ((_a = object.rewards) === null || _a === void 0 ? void 0 : _a.map(e => coin_1.Coin.fromAmino(e))) || [];
        if (object.calculated_height !== undefined && object.calculated_height !== null) {
            message.calculatedHeight = BigInt(object.calculated_height);
        }
        if (object.calculated_time !== undefined && object.calculated_time !== null) {
            message.calculatedTime = timestamp_1.Timestamp.fromAmino(object.calculated_time);
        }
        return message;
    },
    toAmino(message) {
        const obj = {};
        obj.id = message.id ? message.id.toString() : undefined;
        obj.rewards_address = message.rewardsAddress;
        if (message.rewards) {
            obj.rewards = message.rewards.map(e => e ? coin_1.Coin.toAmino(e) : undefined);
        }
        else {
            obj.rewards = [];
        }
        obj.calculated_height = message.calculatedHeight ? message.calculatedHeight.toString() : undefined;
        obj.calculated_time = message.calculatedTime ? timestamp_1.Timestamp.toAmino(message.calculatedTime) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.RewardsRecord.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.RewardsRecord.decode(message.value);
    },
    toProto(message) {
        return exports.RewardsRecord.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/archway.rewards.v1.RewardsRecord",
            value: exports.RewardsRecord.encode(message).finish()
        };
    }
};
function createBaseFlatFee() {
    return {
        contractAddress: "",
        flatFee: coin_1.Coin.fromPartial({})
    };
}
exports.FlatFee = {
    typeUrl: "/archway.rewards.v1.FlatFee",
    encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.contractAddress !== "") {
            writer.uint32(10).string(message.contractAddress);
        }
        if (message.flatFee !== undefined) {
            coin_1.Coin.encode(message.flatFee, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFlatFee();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.contractAddress = reader.string();
                    break;
                case 2:
                    message.flatFee = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            contractAddress: (0, helpers_1.isSet)(object.contractAddress) ? String(object.contractAddress) : "",
            flatFee: (0, helpers_1.isSet)(object.flatFee) ? coin_1.Coin.fromJSON(object.flatFee) : undefined
        };
    },
    toJSON(message) {
        const obj = {};
        message.contractAddress !== undefined && (obj.contractAddress = message.contractAddress);
        message.flatFee !== undefined && (obj.flatFee = message.flatFee ? coin_1.Coin.toJSON(message.flatFee) : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseFlatFee();
        message.contractAddress = (_a = object.contractAddress) !== null && _a !== void 0 ? _a : "";
        message.flatFee = object.flatFee !== undefined && object.flatFee !== null ? coin_1.Coin.fromPartial(object.flatFee) : undefined;
        return message;
    },
    fromAmino(object) {
        const message = createBaseFlatFee();
        if (object.contract_address !== undefined && object.contract_address !== null) {
            message.contractAddress = object.contract_address;
        }
        if (object.flat_fee !== undefined && object.flat_fee !== null) {
            message.flatFee = coin_1.Coin.fromAmino(object.flat_fee);
        }
        return message;
    },
    toAmino(message) {
        const obj = {};
        obj.contract_address = message.contractAddress;
        obj.flat_fee = message.flatFee ? coin_1.Coin.toAmino(message.flatFee) : undefined;
        return obj;
    },
    fromAminoMsg(object) {
        return exports.FlatFee.fromAmino(object.value);
    },
    fromProtoMsg(message) {
        return exports.FlatFee.decode(message.value);
    },
    toProto(message) {
        return exports.FlatFee.encode(message).finish();
    },
    toProtoMsg(message) {
        return {
            typeUrl: "/archway.rewards.v1.FlatFee",
            value: exports.FlatFee.encode(message).finish()
        };
    }
};
//# sourceMappingURL=rewards.js.map